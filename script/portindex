#!/usr/bin/perl -w

# Copyright (c) 2004 Matthew Seaman. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#    1.  Redistributions of source code must retain the above
#        copyright notice, this list of conditions and the following
#        disclaimer.
#
#    2.  Redistributions in binary form must reproduce the above
#        copyright notice, this list of conditions and the following
#        disclaimer in the documentation and/or other materials
#        provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

# @(#) $Id: portindex,v 1.10 2004-10-07 09:56:26 matthew Exp $
#
# Read the ports index file and parse it into a series of
# objects. Scan the ports tree for updates since the last index was
# built, run 'make describe' for those ports, integrate the results
# with the rest of the INDEX data, plus delete the data for any ports
# deleted from the tree.  Print out an updated INDEX file.

use strict;
use warnings;
use POSIX qw(strftime);
use File::Find;
use vars qw($base $verbose);

use FreeBSD::Port;
use FreeBSD::Ports::Tree;

$0 =~ s@.*/@@;    # Script name for error messages
$::verbose = 1;   # Be garrulous.

#-------------------------------------------------------------------------

# Recurse through all of the Makefiles -- expand the SUBDIR argument
# from each Makefile, and all of the Makefiles in the referenced
# directories.  If no SUBDIRs are found, this is a leaf directory, in
# which case investigate the port more thoroughly to determine if it
# has been updated since the INDEX was last generated.
#
# As the leaf directories are checked, delete them from the
# %{$oldports} structure and insert them into %{$newports}: this will
# strip outmoved or deleted ports.

sub scan_makefiles($$$$)
{
    my $dir      = shift;
    my $oldports = shift;
    my $newports = shift;
    my $pkg      = shift;
    my $subdirs;

    $subdirs = get_subdirs($dir);

    if ( @{$subdirs} ) {

        # Regenerate the subdir structure
        insert_pkg( $newports, {}, $dir );

        for my $subd ( @{$subdirs} ) {

            # Use & to suppress prototype check...
            &scan_makefiles( $subd, $oldports, $newports, $pkg->{$subd} );
        }
    } else {
        process_pkg( $oldports, $newports, $dir, $pkg );
    }
    return;
}

# Read out the value of the SUBDIR variable in the Makefile in the
# directory in the argument.
sub get_subdirs($)
{
    my $dir = shift;
    my @subdirs;

    # Hmmm... Using make(1) to print out the value of the variable
    # (make -V SUBDIRS) takes about 200 times as long as just scanning
    # the Makefiles for definitions of the SUBDIR variable.  Be picky
    # about the format of the SUBDIR assignment lines: SUBDIR is used
    # in some of the leaf Makefiles, but in a different style.

    open( MAKEFILE, '<', "${base}/${dir}/Makefile" )
      or do {
        warn "$0: Can't open Makefile in $dir -- $!\n";
        return \@subdirs;    # Leave empty.
      };
    while (<MAKEFILE>) {

        # Return the path relative to $::base
        push @subdirs, ( $dir ? "$dir/$1" : $1 )
          if (m/^\s*SUBDIR\s+\+=\s+(\S+)\s*$/);
    }
    close MAKEFILE;
    return \@subdirs;
}

# Compare version of the pkg data read from the INDEX ($pkg) with
# what's on disk ($dir), moving the leaf entries from $oldports to
# $newports and modifying the contents accordingly.  Create any
# missing entries.
sub process_pkg($$$$)
{
    my $oldports = shift;
    my $newports = shift;
    my $dir      = shift;
    my $pkg      = shift;
    my $pkgx;

    # if this is a new port, $pkg and $pkgx should both be undef...
    $pkgx = $oldports->delete($dir);

    if ( defined($pkgx) != defined($pkg) && $pkgx != $pkg ) {
        warn "$0: it's all gone horribly wrong! $pkg != $pkgx\n";
    }

    # [...]

    $newports->insert( $dir, $pkg );

    return;
}

#-------------------------------------------------------------------------

MAIN:
{
    my $tree;

    $tree = FreeBSD::Ports::Tree->new();

    $tree->read_index(*STDIN);

    # Scan through the Makefiles in the ports tree looking for ports
    # which have files updated more recently than the current ports
    # INDEX.  Compare the 'SUBDIR' links in the Makefiles with the
    # port origins to find added or deleted ports

    $tree->print_index(*STDOUT);
}

#
# That's All Folks!
#
