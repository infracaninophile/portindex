#!/usr/bin/perl -w

# Copyright (c) 2004 Matthew Seaman. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#    1.  Redistributions of source code must retain the above
#        copyright notice, this list of conditions and the following
#        disclaimer.
#
#    2.  Redistributions in binary form must reproduce the above
#        copyright notice, this list of conditions and the following
#        disclaimer in the documentation and/or other materials
#        provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

# @(#) $Id: cache-update,v 1.8 2004-10-19 11:23:27 matthew Exp $
#

# Generate an incremental update to the cached 'make describe' output,
# for the listed port origins.  Requires (a) previously build cache of
# the whole ports tree, including a table showing which ports are
# slave ports and which are masters and (b) a method for automatically
# determining which ports were affected since the last cache update
# (Not yet implemented -- but will involve parsing the cvsup checkouts
# file).
#
# Running the make_describe method on a candidate port will chdir to
# that path and run 'make describe' in the given directory, process
# that output into a FreeBSD::Port object, and save a frozen version
# into the ports cache.  It will also run 'make -V MASTERDIR' and
# record that output in the masterslave file if MASTERDIR is not the
# same as CWD.  Failing to run 'make describe' successfully results in
# that port data being removed from the cache -- which is how
# deletions and port moves are handled.
#
# The Master/Slave port relationships recorded from a previous run are
# applied to force an update for all slave ports whenever the master
# port is updated.
#
# TODO:
#
# Documentation, documentation, documentation!
#

use strict;
use warnings;

use FreeBSD::Portindex qw(read_config);
use FreeBSD::Port;
use FreeBSD::Ports::Tree;

our %Config;
our $pkgname = 'portindex';

$0 =~ s@.*/@@;    # Script name for error messages

# Just read a list of port origins, one per line, from the given file
# handle (default STDIN).
sub read_plain (*$)
{
    my $FH      = shift;
    my $updates = shift;

    while (<$FH>) {
        chomp;
        push @{$updates}, $_;
    }
    return $updates;
}

# Process the data read from the given filehandle assuming it to be
# the output of cvsup(1) [ need atleast -L 1 verbosity ].  Pick out
# the names of updated files, then convert that into a list of port
# origins to process for updates.
sub read_cvsup_output (*$)
{
    my $FH      = shift;
    my $updates = shift;
    my %ports;

    while (<$FH>) {
        chomp;
        if ( my ($p) = m@(ports/[^/]+/[^/]+)/@g ) {
            $ports{$p}++
              unless $p =~ m@/(Mk|Templates|Tools|distfiles|packages)/@;
        }
    }
    for my $p ( keys %ports ) {
        push @{$updates}, "/usr/$p";
    }
    return $updates;
}

# Scan through the cvsup checkouts file -- usually
# /usr/sup/ports-all/checkouts.cvs:. under 4.x -- and find all of the
# file entries marked with an mtime later than some cutoff point.  The
# cutoff point should be about 1 hour earlier than the last time
# cache-update or cache-init was run, as determined by the mtime of
# the DB cache files.
sub read_cvsup_checkouts (*$$)
{
    my $FH         = shift;
    my $updates    = shift;
    my $cutofftime = shift;
    my %seen;

    while (<$FH>) {
        my $name;
        my $rcs_attr;
        my @rcs_attrs;

        chomp;

        # Assume checkout mode: only look at files (C = currently
        # existing, c = used to be present, but now deleted).

        next unless m/^[cC]/;

        # Extract the important data from the checkouts line

        ( undef, $name, undef, undef, $rcs_attr, undef ) = split ' ', $_, 6;

        # If we've already marked this port for checking, or it's part
        # of the infrastructure rather than an actual port, there's no
        # point repeating all of the expensive manipulations in the
        # rest of the loop.

        next
          unless ( $name =~ m@(ports/[^/]+/[^/]+)/@g
            && $name !~ m@/(Mk|Templates|Tools|distfiles|packages)/@ );

        $name = $1;

        next if ( $seen{$name} );

        # Unpick the $rcs_attr record.

        @rcs_attrs = decode_attrs($rcs_attr);

        if ( $rcs_attrs[2] > $cutofftime ) {
            push @{$updates}, "/usr/$name";
            $seen{$name}++;
        }
    }
    return $updates;
}

sub decode_attrs ($)
{
    my $rcs_attr = shift;
    my @attrs;
    my @rcs_attrs;

    # Unpick the $rcs_attr record.
    @attrs = split '#', $rcs_attr;
    while ( $attrs[0] ) {
        my $n = shift @attrs;

        push @rcs_attrs, substr $attrs[0], 0, $n, '';
    }
    return @rcs_attrs;
}

MAIN:
{
    my $tree;
    my $allports;
    my %masterslave;
    my @updates;
    my $counter = 0;
    my %seen;

    read_config( \%Config );

    $tree = FreeBSD::Ports::Tree->new(
        -Env           => { -Home => $Config{CacheDir}, },
        -CacheFilename => $Config{CacheFilename},
        -MasterSlaveFilename => $Config{MasterSlaveFilename},
    );

    # Read the list of ports to re-check and update for the
    # appropriate input format

    if ( $Config{InputFormat} eq 'plain' ) {
        read_plain( *STDIN, \@updates );
    } elsif ( $Config{InputFormat} eq 'cvsup-output' ) {
        read_cvsup_output( *STDIN, \@updates );
    } elsif ( $Config{InputFormat} eq 'cvsup-checkouts' ) {
        my $cutofftime;

        $cutofftime = ( stat "$Config{CacheDir}/$Config{CacheFilename}" )[9]
          or die "$0: can't stat $Config{CacheFilename} -- $!";
        $cutofftime -= $Config{PropagationDelay};

        read_cvsup_checkouts( *STDIN, \@updates, $cutofftime );
    } else {
        die "$0: InputFormat \'$Config{InputFormat}\' unrecognised";
    }

    # If one of the ports given in the @updaters list is the master of
    # several slave ports, add all of those slave ports to the
    # @updaters list, unconditionally.  This only works if the cache
    # is largely complete.

    $tree->masterslave( \%masterslave );

    # Update the entries for the ports read from STDIN, plus the
    # slaves of any masters listed.

    @updates = grep { !$seen{$_}++ } @updates,
      map { @{ $masterslave{$_} || [] } } @updates;

    # Regenerate the FreeBSD::Port objects for all listed ports

    for my $path ( sort @updates ) {
        $counter++;
        print STDERR "$0:$counter: Updating cached data for $path\n"
          if $Config{Verbose};
        $tree->make_describe($path);
    }
}

__END__

=head1 NAME

cache-update -- Incrementally update the portindex cache
	
=head1 SYNOPSIS

cache-update [options]
	
=head1 OPTIONS

=over 8

=item B<--help>

Print a brief usage message and exit.

=item B<--verbose>

Turn on verbose output printed to STDERR.

=back
	
=head1 DESCRIPTION

B<cache-update> makes incremental updates to the B<portindex> cache.

=cut

#
# That's All Folks!
#
